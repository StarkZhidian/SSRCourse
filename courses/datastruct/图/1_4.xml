<?xml version="1.0" encoding="utf-8"?>
<contents>
    <最小生成树--Kruskal算法>
        <text>
            Kruskal算法的思想，简单来说，就是如果一个图有 n 个顶点，选出总权值最小并且不会构成回路的 n-1 条边使得图中的任意两个顶点都能通过这 n-1
            条边中的若干条边连通。"换行"
            这里可能有些小伙伴要问了，为什么选择 n-1 条边就能使得图的任意两个顶点连通？
            因为在图中的两个顶点之间如果没有回路的话最多相隔 n-1 条边，
            不信的话你可以画几个图看看（注意这里说的是没有回路的图）。"换行"
            基于以上思想，在实现 Kruskal算法的时候，我们先得给图的边按权值从小到大排序，
            还有一个关键点是怎么判断一条边加入生成树中会不会使得生成树产生回路。"换行"
            我们可以将已经选择了的边的顶点看做一个集合（它们有共同的祖先），对于没有加入生成树的顶点将它们每个顶点单独看成一个集合。"换行"那么我们选择边的时候只需要判断边的两个顶点是不是在同一个集合中，如果不在同一个集合中，那么这条边和已经加入生成树的边就不会产生回路，就可以选择这条边，否则的话就不能加入生成树中。"换行"重复这个过程，直到选择了
            n-1 条边。"换行"
            依然一下面的有权图为例，通过 Kruskal算法来求出其的最小生成树：
        </text>
        <img>
            tu_8.png
        </img>
        <text>
            最小生成树的构造过程如下：
        </text>
        <img>
            tu_11.png
        </img>
        <text>
            关于 Kruskal算法的实现请参考"动画"和"代码"部分。"换行"
        </text>
        <link>
            参考博客：http://blog.csdn.net/hacker_zhidian/article/details/61419856
        </link>
        <animation html_path="" animation_name="图:克鲁斯卡尔算法"></animation>
        <code>

            /**
            * 实现图的最小生成树算法：Kruskal算法
            * 使用邻接矩阵来储存图的信息
            * Author：指点
            */
            #include &lt;stdio.h&gt; // 表示图的顶点最大数
            #define MAX_NODE_SUM 1000
            // 指定图中边权值的极限值(代表∞)
            #define INF 999999999
            // 表示图的边的信息的结构体：开始顶点、结束顶点和边的权值：
            typedef struct Edge {
            int start;
            int end;
            int weight;
            }Edge;
            // 储存图的边的信息的结构体数组
            Edge edge[MAX_NODE_SUM*MAX_NODE_SUM];
            // 储存图顶点所在集合的祖先数组，用于判断生成树的顶点是否会构成环
            int nodeSet[MAX_NODE_SUM];
            // 最小生成树的权值，初始为 0
            int sumWeight = 0;

            // 利用快速排序来对图的边按权值从小到大排序
            void quickSort(Edge edge[], int start, int end) {
            Edge t;
            int i = start, j = end, temp = edge[start].weight;
            if(start &gt;= end) {
            return ;
            }
            while(i &lt; j) {
            while(i &lt; j &amp;&amp; edge[j].weight &gt;= temp) {
            j--;
            }
            // 找到并交换右边第一个比基数小的元素
            t = edge[i];
            edge[i] = edge[j];
            edge[j] = t;

            while(i &lt; j &amp;&amp; edge[i].weight &lt;= temp) {
            i++;
            }
            // 找到并交换左边第一个比基数大的元素
            t = edge[i];
            edge[i] = edge[j];
            edge[j] = t;
            }
            // 分治递归
            quickSort(edge, start, i-1);
            quickSort(edge, i+1, end);
            }

            // 寻找顶点n 所在集合的祖先顶点编号
            int findParent(int n) {
            // 如果顶点 n的祖先就是它本身，那么直接返回顶点编号
            if(nodeSet[n] == n) {
            return n;
            }
            // 递归寻找祖先顶点，并把途中找到的顶点都设置为同一个祖先顶点
            return nodeSet[n] = findParent(nodeSet[n]);
            }

            // 合并两个顶点所在的集合
            void merge(int n, int m) {
            int p1, p2;
            p1 = findParent(n);
            p2 = findParent(m);
            /* 如果两个顶点所在集合祖先不同，那么合并这两个顶点所在集合，
            * 即把顶点n 的祖先变为顶点m 的祖先
            */
            if(p1 != p2) {
            nodeSet[p1] = p2;
            }
            }

            // Kruskal 算法求出图的最小生成树，nodeSum 为图的顶点总数，edgeSum 为图的边总数
            int kruskal(Edge edge[], int nodeSum, int edgeSum) {
            // 生成树中已经加入的边的数
            int count = 0;
            int i;
            // 顶点集合初始化，每个顶点所在集合的祖先就是这个顶点本身
            for(i = 1; i &lt;= nodeSum; i++) {
            nodeSet[i] = i;
            }
            // 对边进行按权值排序
            quickSort(edge, 1, edgeSum);
            // 不断向生成树中加边，直到加到 edgeSum-1 条边为止
            for(i = 1; i &lt;= edgeSum &amp;&amp; count &lt; edgeSum; i++) {
            // 如果边的两个顶点不在一个集合中，证明将这条边加入生成树中不会构成回路
            if(findParent(edge[i].start) != findParent(edge[i].end)) {
            // 将这条边加入生成树中
            merge(edge[i].start, edge[i].end);
            count++;
            // 更新生成树总权值
            sumWeight += edge[i].weight;
            }
            }

            return sumWeight;
            }

            int main() {
            // 图的顶点数和边数
            int nodeSum, edgeSum;
            // 边的开始顶点编号、结束顶点编号和边的权值
            int start, end, weight;
            int i, j;
            printf("输入图的顶点数和边数：");
            scanf("%d %d", &amp;nodeSum, &amp;edgeSum);
            if(nodeSum == 0) {
            return 0;
            }
            // 输入边的信息，更新顶点之间的距离
            for(i = 1; i &lt;= edgeSum; i++) {
            printf("输入第 %d 条边的开始顶点编号、结束顶点编号和边的权值：", i);
            scanf("%d %d %d", &amp;start, &amp;end, &amp;weight);
            edge[i].start = start;
            edge[i].end = end;
            edge[i].weight = weight;
            }

            printf("最小生成树的权值总和：%d \n", kruskal(edge, nodeSum, edgeSum));

            return 0;
            }
        </code>
        <text>
            上面的代码中使用了快速排序的思想，关于快速排序，可以看参考"快速排序"部分。"换行"
            如果你对 C++ 中 STL 模板熟悉，也可以直接使用其中的 sort 方法。"换行"
            关于 Kruskal算法的时间复杂度，算法主要把时间花费在对边的排序上，这里采用的是快速排序，所以时间复杂度为O(m*log(m))，m 为图的边总数。"换行""换行"
            以上图中有权图作为数据源，运行程序：
        </text>
        <img>
            tu_12.png
        </img>
    </最小生成树--Kruskal算法>


    <最小生成树--Prim算法>
        <text>
            这篇内容介绍一下图的最小生成树算法，关于图的生成树的概念请参考"图的简介"部分。"换行"
            那么为什么要求出图的最小生成树呢？"换行"假设你现在在为一个城市修路，
            你需要使得这个城市之间的任意两个小城镇之间有直接或者间接的道路相连，怎么样使得修路的费用最小呢？"换行"
            这其实就是一个图的最小生成树问题，城市中的城镇就是图的顶点，道路就是边，道路长度就是边的权值。"换行"
            我们是要在连通所有城镇的情况下找出所有道路权值之和最小的修路方案。"换行"
            求一个图的最小生成树一般有两种常用的算法：普里姆(Prim)算法和克鲁斯卡尔(Kruskal)算法。"换行"
            Kruskal算法在下一部分会介绍，先看一下Prim算法的思想和步骤："换行"
            1、初始化生成树，没有任何顶点，生成树到所有顶点的距离都为 INF。"换行"
            2、选择连通图中的任意一个顶点V0 作为生成树根节点加入生成树中，
            并通过顶点V0 的边缩短更新生成树到其他顶点的距离。"换行"
            3、选出距离当前生成树最近并且还未被加入生成树的顶点Vi 加入生成树中，通过顶点Vi 来缩短生成树到其他顶点的距离。"换行"
            4、重复步骤3 ，直到图的所有顶点都加入到生成树中，此时的生成树就是最小生成树。"换行"
            总的来说其实 Prim 就是不断的向生成树中加入当前距离生成树最近并且还未加入生成树的顶点。"换行"可称为"加点法"。"换行"
            下面以一个有权图为例，来看一下怎么通过 Prim 算法构造我们需要的最小生成树：
        </text>
        <img>
            tu_8.png
        </img>
        <text>
            最小生成树的构造过程如下：
        </text>
        <img>
            tu_9.png
        </img>
        <text>
            关于 Prim算法的实现请参考"动画"和"代码"部分。"换行"
        </text>
        <link>
            参考博客：http://blog.csdn.net/hacker_zhidian/article/details/61419856
        </link>
        <animation html_path="">图:普里姆算法</animation>
        <code>

            /**
            * 实现图的最小生成树：Prim 算法
            * 使用邻接矩阵来储存图的信息
            * Author：指点
            */
            #include &lt;stdio.h&gt; // 表示图的顶点最大数
            #define MAX_NODE_SUM 1000
            // 指定图中边权值的极限值(代表邻接矩阵中的∞)
            #define INF 999999999
            // 储存图信息的临接矩阵
            int graph[MAX_NODE_SUM][MAX_NODE_SUM];
            // 最小生成树的权值，初始为 0
            int sumWeight = 0;
            // 代表最小生成树到图中每个顶点的距离，初始值为 INF
            int dis[MAX_NODE_SUM] = {INF};
            // 标志顶点是否已经被加入生成树中
            int visit[MAX_NODE_SUM] = {0};
            // 已加入生成树中的顶点数
            int count = 0;

            // 实现 Prim 算法，nodeSum 为图的顶点总数
            int prim(int nodeSum) {
            int i;
            int minWeight, minNode;
            // 将顶点 1 作为最小生成树的根节点并标记
            visit[1] = 1;
            count++;
            // 利用顶点1 来更新最小生成树到每个顶点的距离
            for(i = 1; i &lt;= nodeSum; i++) {
            dis[i] = graph[1][i];
            }
            // 当加入最小生成树的顶点小于图的顶点总数的时候继续循环
            while(count &lt; nodeSum) {
            // 循环选出还未加入到最小生成树中并且距离最小生成树最近的顶点
            minWeight = INF;
            for(i = 1; i &lt;= nodeSum; i++) {
            if(visit[i] == 0 &amp;&amp; minWeight &gt; dis[i]) {
            minWeight = dis[i];
            minNode = i;
            }
            }
            // 将当前距离最小生成树最近的顶点加入最小生成树中, 并且更新最小生成树的权值。"换行"
            visit[minNode] = 1;
            count++;
            sumWeight += minWeight;
            // 利用这个顶点来更新最小生成树到其他还未加入最小生成树的顶点的距离
            for(i = 1; i &lt;= nodeSum; i++) {
            if(visit[i] == 0 &amp;&amp; dis[i] &gt; graph[minNode][i]) {
            dis[i] = graph[minNode][i];
            }
            }
            }
            return sumWeight;
            }

            int main() {
            // 图的顶点数和边数
            int nodeSum, edgeSum;
            // 边的开始顶点编号、结束顶点编号和边的权值
            int start, end, weight;
            int i, j;
            printf("输入图的顶点数和边数：");
            scanf("%d %d", &amp;nodeSum, &amp;edgeSum);
            if(nodeSum == 0) {
            return 0;
            }
            // 对储存图的邻接矩阵初始化
            for(i = 1; i &lt;= nodeSum; i++) {
            for(j = 1; j &lt;= nodeSum; j++) {
            /* 如果 i 和 j 相等，即为同一个顶点，那么权值为 0 ，
            * 否则先假设顶点 i 和顶点 j 之间的边的权值为 INF(即为没有边相连)
            */
            if(i == j) {
            graph[i][j] = 0;
            } else {
            graph[i][j] = INF;
            }
            }
            }
            // 输入边的信息，更新顶点之间的距离
            for(i = 1; i &lt;= edgeSum; i++) {
            printf("输入第 %d 条边的开始顶点编号、结束顶点编号和边的权值：", i);
            scanf("%d %d %d", &amp;start, &amp;end, &amp;weight);
            graph[start][end] = graph[end][start] = weight;
            }

            printf("图的邻接矩阵的信息: \n");
            for(i = 1; i &lt;= nodeSum; i++) {
            for(j = 1; j &lt;= nodeSum; j++) {
            printf("%-10d ", graph[i][j]);
            }
            printf("\n");
            }

            printf("\n最小生成树的权值总和：%d \n", prim(nodeSum));

            return 0;
            }
        </code>
        <text>
            这里给出的Prim算法的时间复杂度为O(n*n)，n为图的顶点数，以上面给出的有权图作为数据源，运行程序，得出程序运行结果：
        </text>
        <img>
            tu_10.png
        </img>
    </最小生成树--Prim算法>
</contents>