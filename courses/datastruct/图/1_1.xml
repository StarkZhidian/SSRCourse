<?xml version="1.0" encoding="UTF-8"?>

<contents>
	<text>
前面我们介绍了元素之间具有线性关系的线性结构和元素之间具有层次关系的树结构，
但是生活中还有很多其他的结构需要表示，比如：错综复杂的地图：地图中的地点之间的道路可以是任意的，
也就是说将地图中的地名看成节点，道路看成边，那么每一个节点都可能和任意一个其他的节点有联系。"换行"
这个时候我们即不能用线性结构来表示，也不能用树结构来表示，那么这里就需要用到一种新的数据结构：图(Graph)。"换行"
图是由顶点的有穷非空集合和顶点之间边的集合组成，通常表示为G(V,E)，其中，
G表示一个图，V是图G中顶点的集合，E是图G中边的集合。"换行"
对于图来说，有有向图和无向图之分，无边图：图中所有顶点之间的边都没有方向。"换行"
那么有向图就是顶点之间的每一条边都有方向。"换行"下面是有向图和无向图的结构图：
	</text>
	<img>
tu_1.png
	</img>
	<text>
下面是图中的一些基本术语：
有向边：假设顶点i 和顶点 j有边相连，如果这条边是没有方向的，那么其为有向边，写为&lt;a, b&gt;(方向为a-&gt;b)
无向边：假设顶点i 和顶点 j有边相连，如果这条边是没有方向的，那么其为无向边，写为(a,b)，
在某个方面来看，一条无向边(a, b)可以看做两条有向边：&lt;a, b&gt; 和 &lt;b, a&gt;
有向边也称为弧；"换行"开始顶点称为弧尾，结束顶点称为弧头；"换行"
完全无向图：若有n个顶点的无向图有n(n-1)/2 条边, 则此图为完全无向图。"换行"
完全有向图：有n个顶点的有向图有n(n-1)条边, 则此图为完全有向图。"换行"
邻接点：假设顶点a 和顶点b 之间有边相连，那么 a b 顶点互称为邻接点。"换行"
稀疏图：边相对于顶点来说很少的图(一般少于 nlog(n) 的图，n为图的顶点数)；"换行"
稠密图：边很多的图(一般大于 nlog(n) 的图，n为图的顶点数)；"换行"
权重：图中的边可能会带有一个权重，为了区分边的长短；"换行"
有权图：图中连接顶点的每条边有代表一定意义的数值
网：边带有权重的图；"换行"
度：与特定顶点相连接的边数；"换行"
出度、入度：对于有向图的概念，出度表示此顶点为起点的边的数目，入度表示此顶点为终点的边的数目；"换行"
连通图：如果对于图中任意两个顶点都是连通的，那么它就是连通图；"换行"
极大连通子图：包含竟可能多的顶点(必须是连通的)，
即找不到另外一个顶点，使得此顶点能够连接到此极大连通子图的任意一个顶点；"换行"
连通分量：极大连通子图的数量；"换行"
强连通图：此为有向图的概念，表示任意两个顶点a，b，使得a能够连接到b，b也能连接到a 的图；"换行"
生成树：包括了图中的 n 个顶点，n-1 条边，并且保证 n 个顶点相互连通(即不存在环)；"换行"
最小生成树：此图的生成树中的边的权重之和是所有生成树中最小的(对于有权图而言)；"换行"
	</text>
	<text>
怎么去保存一个图呢？对于图的储存，我们可以采用邻接矩阵和邻接表的形式。"换行"
怎么邻接矩阵去表示一个图呢，假设一个图有 n 个顶点，我们可以建立一个 n*n 的二维数组(a[n][n])，
如果从顶点i(Vi)到顶点j(Vj)之间有边相连，那么a[i][j] = 1，否则为 0 。"换行"这样就实现了使用邻接矩阵表示图。"换行"
使用邻接表储存图，对于图的每个顶点，我们可以使用单链表的形式来保存和这个顶点相连的其他顶点的信息，
假设现在要对图的第一个顶点的信息进行储存，我们可以将储存这个顶点信息的链表节点作为单链表的头结点，然后将储存其它和这个顶点相连的顶点的链表节点插入到头结点后面，类似于通过后插法创建单链表。"换行"如果想了解更多的关于单链表的信息，
请参考"单向链表"部分内容。"换行"如果一个图有 n 个顶点，那么我们需要创建 n 个单链表来储存这 n 个顶点的信息，
一个方法是创建一个大小为 n 的数组指针来储存 n 个顶点的链表头节点。"换行"
以上图中的无向图为例，下面给出无权无向图和有权无向图的邻接矩阵和邻接表的结构图：
关于图的邻接矩阵和邻接表的创建，请参考"动画"和"代码"部分。"换行"
	</text>
	<img>
tu_2.png
	</img>
	<img>
tu_3.png
	</img>
	<code>

/**
* 实现无权无向图的临接矩阵和邻接表储存
* Author：指点
*/
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt; 
// 表示图的顶点最大数
#define MAX_NODE_SUM 1000
// 储存图信息的临接矩阵
int graph[MAX_NODE_SUM][MAX_NODE_SUM];

// 储存图顶点信息的结构体：顶点编号(number)、指向和链表头结点代表的顶点相连的下一个顶点的指针(next)
typedef struct Node {
int number;
struct Node *next;
}Node; 
// 储存图的邻接表中单链表头结点的指针数组 
Node *node[MAX_NODE_SUM] = {NULL};


int main() {
// 图的顶点数和边数
int nodeSum, edgeSum;
// 边的开始顶点编号和结束顶点编号
int start, end;
// 为顶点申请内存空间的中间指针变量 
Node *point = NULL; 
int i, j;
printf("输入图的顶点数和边数：");
scanf("%d %d", &amp;nodeSum, &amp;edgeSum);
if(nodeSum &lt;= 0) {
	return 0;
}
// 为邻接表中每一个顶点所在单链表的头结点申请空间 
for(i = 1; i &lt;= nodeSum; i++) {
	node[i] = (Node *) malloc(sizeof(Node));
	node[i]-&gt;number = 0;
	node[i]-&gt;next = NULL;
} 
for(i = 1; i &lt;= edgeSum; i++) {
	printf("输入第 %d 条边的开始顶点编号和结束定点编号：", i);
	scanf("%d %d", &amp;start, &amp;end);
	// 因为是无向图，所以每一条无向边可以看成双向的有向边 
	graph[start][end] = graph[end][start] = 1;

	/* 对邻接表进行操作：
	 * 为保存顶点信息的结构体指针申请空间
	 */ 
	point = (Node *) malloc(sizeof(Node));
	point-&gt;number = end;
	// 将编号为 end 的顶点插入到邻对应单链表的头结点后面 
	point-&gt;next = node[start]-&gt;next;
	node[start]-&gt;next = point;
	// 和编号为 start 的顶点相连的顶点个数 +1  
	node[start]-&gt;number++; 
	
	// 为保存顶点信息的结构体指针申请空间 
	point = (Node *) malloc(sizeof(Node));
	point-&gt;number = start;
	// 将编号为 start 的顶点插入到邻对应单链表的头结点后面 
	point-&gt;next = node[end]-&gt;next;
	node[end]-&gt;next = point;
	// 和编号为 end 的顶点相连的顶点个数 +1  
	node[end]-&gt;number++; 
}

printf("图的邻接矩阵：\n"); 
for(i = 1; i &lt;= nodeSum; i++) {
	for(j = 1; j &lt;= nodeSum; j++) {
		printf("%d ", graph[i][j]);
	}
	printf("\n");
}

printf("图的邻接表：\n"); 
for(i = 1; i &lt;= nodeSum; i++) {
	point = node[i];
	printf("和顶点 %d 连接的顶点数：%d，其单链表为：%d", i, point-&gt;number, i);
	point = point-&gt;next;
	while(point != NULL) {
		printf(" --&gt; %d", point-&gt;number);
		point = point-&gt;next;
	}
	printf("\n");
} 

return 0;
}

	</code>
	<text>
上面实现的是无向无权图的邻接矩阵和邻接表储存，
以上图中给到的无向图作为数据来源(顶点A B C D 分别代表编号为 1 2 3 4 的顶点)，
对于有权图，我们先得给两个没有边相连的顶点之间的权值设定为一个极大值(代表上图有权图中邻接矩阵中的∞)。"换行"
然后再对邻接矩阵进行赋值，而关于邻接表，可以在表示顶点信息的结构体中加一个变量表示其和链表头结点代表的顶点之间的边的权值：
	</text>
	<code>
/* 表示图的顶点信息的结构体：顶点编号(number)，
* 其和单链表头结点代表的顶点之间的边的权值(weight)，指向和链表头结点代表的顶点相连的下一个顶点的指针(next)
*/
typedef struct Node {
int number;
int weight;
struct Node *next;
};
	</code>
	<text>
最后是上面程序的运行结果：
	</text>
	<img>
tu_4.png
	</img>
</contents>
