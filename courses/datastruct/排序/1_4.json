{"contentList": [{"basicData":{"text":"\n对于选择排序，可能大家没有怎么用过，其实选择排序和冒泡排序有点类似，我们知道，假设使用冒泡排序对一个数组进行从小到大排序，如果我们从左向右边扫描数组，那么第一趟扫描的目的是将数组中最大的数放在数组的最右边。\n第二趟扫描的目的是将数组中第二大的数放在数组的倒数第二个位置....\n那么现在我们使用选择排序对数组进行从小到大排序，同样的，如果我们还是从左向右边扫描数组。\n此时我们第一趟的目的就变成了将数组中最小的元素放到数组的第一个元素，\n第二趟排序的目的就变成了将数组中第二小的元素放到数组的第二个元素中... \n\n当所有的数组元素都放置完毕之后整个数组元素就变得有序。接下来通过一个例子来看一下具体实现方法：\n\n假设我们现在要用选择排序对数组 3 1 2 5 4 从小到大排序。首先，我们先做好准备工作，一开始准备两个变量 i j。并且将 i 指向数组第一个元素（元素 3）。\n\n第一趟扫描，先将 j 指向 i 后面一个数组元素（此时为元素 1），然后比较 i 和 j 指向的数组元素的值的大小：3 大于 1，不符合排序规则，因此交换这两个数组元素，完成之后数组元素变成了：1 3 2 5 4 。之后 j 指向后面一个数组元素（j++），再比较 i 和 j 所指向的数组元素的值的大小：1 小于 2，符合排序规则，j 继续向后移动（j++），再比较 i 和 j 所指向的数组元素的值的大小：1 小于 5，符合排序规则，j 继续向后移动（j++），再比较 i 和 j 所指向的数组元素的值的大小：1 小于 4，符合排序规则，此时 j 已经到达了数组的最后一个元素。那么第一趟扫描结束。此时的数组元素为：1 3 2 5 4 。\n此时将 i 向后移（i++），指向元素 3，即为第二趟扫描做准备。\n\n第二趟扫描，先将 j 指向 i 后面一个元素（此时为元素 2），然后比较 i 和 j 所指向的数组元素的值的大小：3 大于 2，不符合排序规则，交换这两个数组元素，完成之后数组元素变成了：1 2 3 5 4 。之后 j 向后移动（j++），再比较 i 和 j 所指向的数组元素的值的大小：2 小于 5，符合排序规则，j 继续向后移动（j++），再比较 i 和 j 所指向的数组元素的值的大小：2 小于 4，符合排序规则，此时 j 已经到达了数组的最后一个元素。那么第二趟扫描结束。此时的数组元素为：1 2 3 5 4 。\n此时将 i 向后移（i++），指向元素 3 ，即为第三趟扫描做准备。\n\n第三趟排序，同样的，先将 j 指向 i 后面的一个元素（此时为元素 5），然后比较 i 和 j 所指向的数组的元素的值得大小：3 小于 5，符合排序规则，j 向后面移动（j++），再比较 i 和 j 所指向的数组元素的值的大小：3 小于 4，符合排序规则，此时 j 已经到达了数组的最后一个元素。那么第三趟扫描结束。此时的数组元素为：1 2 3 5 4 。\n此时将 i 向后移（i++），指向元素 5 ，即为第四趟扫描做准备。\n\n第四趟排序，将 j 指向 i 后面的一个元素（此时为元素 4），然后比较 i 和 j 所指向的元素的大小：5 大于 4，不符合排序规则，交换这两个数组元素，完成之后数组元素变成了：1 2 3 4 5 。\n此时 j 已经到达了数组的最后一个元素。那么第四趟扫描结束。此时的数组元素为：1 2 3 4 5 。我们注意到，此时 已经进行了 4 趟扫描。每一趟扫描有一个数组元素在正确的数组下标位置上，也就是说现在已经有 4 个元素已经排好序（从小到大分别在数组中第一到第四个元素的位置）。总共有 5 个元素，那么最后一个肯定在数组的第五个元素的位置，所以其实现在数组已经是有序的了。我们在此时结束排序算法。\n\n\n关于选择排序的实现，请参考\"动画\" 和 \"代码\"部分。\n\t"},"contentType":0},{"basicData":{"animation_name":"排序:选择排序"},"contentType":4},{"basicData":{"code":"\n\n/**\n*  C语言实现选择排序\n* Author：指点 \n*/ \n#include <stdio.h>\n#define N 5\n\n// 选择排序第一个版本的实现，将数组元素从小到大排序 \nvoid selectSort1(int a[], int n) {\nint i, j, t;\n// 双重循环，外层循环实现扫描，内层循环实现比较 \nfor (i = 0; i < n-1; i++) {\n\tfor (j = i+1; j < n; j++) {\n\t\t/* 如果前面的数组元素值大于后面的数组元素值（不符合排序规则）， \n\t\t那么交换两个数组元素*/ \n\t\tif (a[i] > a[j]) {\n\t\t\tt = a[i];\n\t\t\ta[i] = a[j];\n\t\t\ta[j] = t;\n\t\t}\n\t}\n}\n}\n\n// 选择排序第二个版本的实现，将数组元素从小到大排序 \nvoid selectSort2(int a[], int n) {\nint i, j, t;\nint minIndex; // 当前未排好序的数组元素中最小的元素值的下标 \n// 双重循环，外层循环实现扫描，内层循环实现比较 \nfor(i = 0; i < n-1; i++) {\n\tminIndex = i;\n\tfor (j = i+1; j < n; j++) {\n\t\t// 比较，找出当前未排好序的数组元素中值最小的数组元素的下标 \n\t\tif (a[minIndex] > a[j]) {\n\t\t\tminIndex = j;\n\t\t}\n\t}\n\t/* 如果当前还未排好序的数组元素中值最小的元素下标不等于 i ，\n\t那么交换这两个数组元素*/ \n\tif (minIndex != i) {\n\t\tt = a[minIndex];\n\t\ta[minIndex] = a[i];\n\t\ta[i] = t;\n\t}\n} \n}\n\nint main() {\nint a[N] = {3, 1, 2, 5, 4};\nint i = 0;\n\nprintf(\"排序前的数组元素：\");\nfor (; i < N; i++) {\n\tprintf(\"%d \", a[i]);\n}\n\nselectSort1(a, N);\n//\tselectSort2(a, N); \n\nprintf(\"\\n排序后的数组元素：\");\nfor (i = 0; i < N; i++) {\n\tprintf(\"%d \", a[i]);\n}\n\nreturn 0;\n} \n\t","code_language":-1},"contentType":2},{"basicData":{"text":"\n上面的代码中展示了两个有细小差别的选择排序代码版本，但这只是针对代码实现方面的，其基本思想仍然一致。\n小伙伴可以仔细思考一下两个版本中哪个版本的代码在优化上更胜一筹。\n\n我们很容易可以看出选择排序的时间复杂度为 O(n*n)。最后来看一下程序运行结果：\n\t"},"contentType":0},{"basicData":{"image_url":"选择排序_1.png"},"contentType":1}]}