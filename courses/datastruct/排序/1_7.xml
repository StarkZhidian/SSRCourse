<?xml version="1.0" encoding="UTF-8"?>

<堆排序>
    <text>
        如果要使用堆排序，我们先得熟悉数据结构：二叉堆，因为堆排序就是在二叉堆的基础上进行的。
        关于二叉堆的相关知识，在“树”模块中的知识点中有介绍。小伙伴可以先看一下。"换行"
        我们知道二叉堆有最小堆和最大堆之分。最小堆即为二叉堆的堆顶元素值不大于其左右子节点的值，
        最大堆即为二叉堆的堆顶元素值不小于其左右子节点的值，请注意，堆的左右子树亦是堆。"换行"
        那么，如果要将元素从小到大排序，我们就要建立一个最小堆来储存要排序的数，如果要将元素从大到小排序，我们就需要建立一个最大堆来储存要排序的数。"换行"
        那么现在假设我们需要用堆排序来对一个数组的元素从小到大排序。首先，我们要创建一个存有要排序的数组元素的最小堆。"换行"
        接下开始排序过程：从当前最小堆中取出堆顶元素，根据最小堆的特性我们知道堆顶元素即为当前堆中最小的元素。之后我们将这个最小堆的最后一个叶子节点作为新的堆顶，并且再次执行构造最小堆的过程......
        不断的重复这个过程，直到整个堆为空，那么我们在这个过程中取出的堆顶元素的值按取出的先后顺序排列就是从小到大有序的。"换行""换行"
        既然知道了从小到大排序的方法，那么我想从大到小排序也很容易理解了。这里就不再重复了。"换行"
        关于堆排序的实现，请参考"动画" 和 "代码"部分。
    </text>
    <animation html_path="" animation_name="排序:堆排序"></animation>
    <code>

        /**
        * C语言实现堆排序
        * Author：指点
        */
        #include &lt;stdio.h&gt; #define N 5

        // 构造最小堆，currentIndex 为当前要构造的堆的根节点下标，n 为数组元素总数
        void createMinHeap(int currentIndex, int a[], int n) {
        // 左右子节点所在数组的下标，请注意数组元素从 0 开始
        int leftChild = currentIndex*2 + 1;
        int rightChild = currentIndex*2 + 2;
        /* 判断当前节点是否有左右孩子节点，如果没有，
        证明当前节点为叶子节点，那么无需进行堆排序 */
        if (leftChild &gt;= n &amp;&amp; rightChild &gt;= n) {
        return ;
        }
        int t; // 交换节点值所用的临时变量
        // 保存当前节点和其左右孩子节点的最小值所在数组下标和节点的最小值
        int minIndex = currentIndex;
        int minValue = a[currentIndex];
        // 找出当前节点和其左右孩子节点中节点值较小的节点
        if (minValue &gt; a[leftChild]) {
        minIndex = leftChild;
        minValue = a[leftChild];
        }
        if (minValue &gt; a[rightChild]) {
        minIndex = rightChild;
        minValue = a[rightChild];
        }
        /* 如果最小值节点不为当前节点，
        那么交换两节点的值并且对 maxIndex 指向的节点构造最小堆 */
        if (minIndex != currentIndex) {
        t = a[minIndex];
        a[minIndex] = a[currentIndex];
        a[currentIndex] = t;
        // 对 minIndex 所指向二叉堆节点构造最小堆
        createMinHeap(minIndex, a, n);
        }
        }

        // 构造最大堆，currentIndex 为当前要构造的堆的根节点下标，n 为数组元素总数
        void createMaxHeap(int currentIndex, int a[], int n) {
        // 左右子节点所在数组的下标，请注意数组元素从 0 开始
        int leftChild = currentIndex*2 + 1;
        int rightChild = currentIndex*2 + 2;
        /* 判断当前节点是否有左右孩子节点，如果没有，
        证明当前节点为叶子节点，那么无需进行堆排序 */
        if (leftChild &gt;= n &amp;&amp; rightChild &gt;= n) {
        return ;
        }
        int t; // 交换节点值所用的临时变量
        // 保存当前节点和其左右孩子节点的最大值所在数组下标和节点的最大值
        int maxIndex = currentIndex;
        int maxValue = a[currentIndex];
        // 找出当前节点和其左右孩子节点中节点值较大的节点
        if (maxValue &lt; a[leftChild]) {
        maxIndex = leftChild;
        maxValue = a[leftChild];
        }
        if (maxValue &lt; a[rightChild]) {
        maxIndex = rightChild;
        maxValue = a[rightChild];
        }
        /* 如果最大值节点不为当前节点，
        那么交换两节点的值并且对 maxIndex 指向的节点构造最大堆 */
        if (maxIndex != currentIndex) {
        t = a[maxIndex];
        a[maxIndex] = a[currentIndex];
        a[currentIndex] = t;
        // 对 maxIndex 所指向二叉堆节点构造最大堆
        createMaxHeap(maxIndex, a, n);
        }
        }

        // 从小到大进行堆排序
        void heapSortIncrease(int a[], int n) {
        int result[n]; // 保存排序结果的数组
        int resIndex = 0;
        int i = 0;
        // 从第一个不是叶子节点开始构造最小堆
        for (i = N/2; i &gt;= 0; i--) {
        createMinHeap(i, a, n);
        }
        // 进行堆排序，当堆中元素个数为 0 时结束
        while (n) {
        // 依次取出堆顶元素并且保存
        result[resIndex++] = a[0];
        // 将最后一个叶子节点值复制到根结点中，即为将最后一个叶子节点作为新的根结点
        a[0] = a[n-1];
        // 剔除最后一个叶子节点（其已经作为根结点）
        n--;
        // 重新构造最小堆
        createMinHeap(0, a, n);
        }
        printf("从小到大堆排序的结果：");
        for (i = 0; i &lt; resIndex; i++) {
        printf("%d ", result[i]);
        }
        printf("\n");
        }

        // 从大到小进行堆排序
        void heapSortDecrease(int a[], int n) {
        int result[n]; // 保存排序结果的数组
        int resIndex = 0;
        int i = 0;
        // 从第一个不是叶子节点开始构造最大堆
        for (i = N/2; i &gt;= 0; i--) {
        createMaxHeap(i, a, n);
        }
        // 进行堆排序，当堆中元素个数为 0 时结束
        while (n) {
        // 依次取出堆顶元素并且保存
        result[resIndex++] = a[0];
        // 将最后一个叶子节点值复制到根结点中，即为将最后一个叶子节点作为新的根结点
        a[0] = a[n-1];
        // 剔除最后一个叶子节点（其已经作为根结点）
        n--;
        // 重新构造最大堆
        createMaxHeap(0, a, n);
        }
        printf("从大到小堆排序的结果：");
        for (i = 0; i &lt; resIndex; i++) {
        printf("%d ", result[i]);
        }
        printf("\n");
        }

        int main() {
        int a[N] = {3, 2, 1, 5, 4};
        int b[N] = {3, 2, 1, 5, 4};
        int i = 0;

        printf("排序前的数组：");
        for (; i &lt; N; i++) {
        printf("%d ", a[i]);
        }
        printf("\n");
        // 从小到大排序
        heapSortIncrease(a, N);

        printf("\n\n");

        printf("排序前的数组：");
        for (i = 0; i &lt; N; i++) {
        printf("%d ", b[i]);
        }
        printf("\n");
        // 从大到小排序
        heapSortDecrease(b, N);

        return 0;
        }
    </code>
    <text>
        看起来代码挺多，但其实主要的逻辑都是在 heapSortIncrease(int a[], int n) 函数和 heapSortDecrease(int a[], int n)
        。因为创建最小堆和创建最大堆的操作其实是属于“二叉堆”部分的内容。如果你理解了二叉堆，相信这个代码对你来说没有多大难度。"换行"
        最后说一下堆排序的时间复杂度，我们知道，创建最小堆/最大堆的时间复杂度为 O(logn)。在这里排序的过程中，我们每从堆顶取出一个元素都要重新创建一次最小堆/最大堆，数组元素一共有 n
        个，因此整个堆排序的时间复杂度为
        O(n*logn)，算是一个高效的排序算法了，但是因为其实现过程较为复杂，因此在一般的应用中并不是很常用，大家更喜欢用代码简短而效率高的快速排序，但是这并不是我们不掌握堆排序的理由，多掌握一种算法总没有坏处。"换行"
        好了，最后来看一下程序运行结果：
    </text>
    <img>
        堆排序_1.png
    </img>
</堆排序>