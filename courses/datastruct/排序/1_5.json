[
  {
    "basicData": {
      "text": "\t\n在此之前，我想大家以前可能听说过甚至已经用过快速排序，可能大家都知道快速排序据说是最快的排序算法。\n那事实真的就是这样，快速排序就是最快的排序算法。其平均复杂度为 O(n*logn)。下面我们就来看一下这个最快的排序算法：\n\n先说一下它的基本思想：\n\n通过一趟快速排序将要排序的数据分割成独立的两部分，其中一部分的所有数据都比另外一部分的所有数据都要小，然后再按此方法对这两部分数据分别进行快速排序，整个排序过程可以递归进行，以此达到整个数据变成有序序列。\n\n可能这个描述对于刚刚接触这个排序算法的人来说有点抽象，那么其实简单来说就是假设现在有一组数要从小到大排序，\n首先，我们在这组数中选取一个哨兵，然后和这组数中所有的数字进行比较，如果数字比哨兵大，那么将其放在这组数的右半部分，否则的话将其放在数组的左半部分。当所有的数字都比完了之后，再把这个哨兵放在这组数中间。\n\n这样一来，这组数就被分成了两个部分：左半部分的数字都不大于哨兵的值，右半部分的数字都不小于哨兵的值。\n那么接下来我们再分别对左半部分和右半部分的数字再进行快速排序，这个过程其实就是上面基本思想里面讲到的\"递归进行\"\"。当所有的元素都完成了快速排序之后，整组数就变成有序的了。\n\n\n我们下面用一个实例来看一下：假设我要用快速排序对数组：3 5 4 1 2 进行从小到大排序：\n首先我们先做好准备工作，用两个变量（i, j）分别指向数组开头元素的下标和数组结尾元素的下标（即为元素 3 和 元素 2），那么接下来我们选取一个哨兵，这里默认选择数组第一个元素 3，并且将元素 3 储存到哨兵元素中。这样，元素 3 在哨兵元素中就有了一个备份。\n\n因为要比较数组中每一个元素和哨兵元素的值，我们先从数组最右边向左边扫描元素：首先是元素 2（j 所指向的数组元素），将元素 2 和哨兵元素的值比较，此时，2 是小于 3 的，那么我们把元素 2 复制到 i 所指的元素中，此时 i 指向的是数组开头元素：元素 3 ，那么复制完成之后数组元素就变成了：2 5 4 1 2，可能有些小伙伴会问了：这样一来元素 3 不就被冲掉了吗？别急，还记得我们开始时把元素 3 作为哨兵储存到哨兵元素中了吗？也就是说元素 3 并没有被冲掉。我们之后会用到它。\n\n接下来，每复制完成一个数我们要换扫描方向，现在扫描方向换成从左到右扫描，首先我们扫描到的元素是元素 2（i 所指向的数组元素），将元素 2 和哨兵元素的值比较，此时 2 是小于 3 的，符合排序规则，我们继续向右边扫描（i++），接下来我们扫描到元素 5 ，将元素 5 和哨兵元素值比较，此时 5 是大于 3 的，不符合排序规则，我们将元素 5 复制到 j 所指向的元素中，此时 j 指向的元素是元素 2（数组最右边的元素），复制完成后数组元素变成了：2 5 4 1 5。\n\n接下来我们再换扫描方向，换成从右向左扫描，此时扫描到的是元素 5 （j 所指向的数组元素），将元素 5 和哨兵元素值比较，此时 5 是大于 3 的，符合排序规则，我们继续向左边扫描（j--），接下来是元素 1，将元素 1 和哨兵元素值比较，此时 1 是小于 3 的，不符合排序规则，我们将元素 1 复制到 i 所指向的元素中，此时 i 所指向的元素是元素 5 （数组左边的元素 5），复制完成后数组元素变成了：2 1 4 1 5。\n\n同上步骤，我们把扫描步骤换成从左到右扫描，此时扫描到的元素是元素 1 （i 所指向的数组元素），将元素 1 和哨兵元素比较，1 小于 3，符合排序规则，我们继续向右扫描（i++）。此时扫描倒的元素是元素 4，将元素 4 和哨兵元素比较，4 大于 3，不符合排序规则，我们将元素 4 复制到 j 所指的元素中，此时 j 所指的元素是元素 1（数组右边的元素 1），复制完成后数组元素边成了：2 1 4 4 5 。\n\n继续换扫描方向为从右向左，此时扫描到的元素是元素 4 （j 所指的数组元素），将元素 4 和哨兵元素比较，元素 4 大于 元素 3，符合排序规则，继续向左扫描（j--）。接下来，请注意：我们发现 j 和 i 的值相等（j 和 i 指向同一个数组元素）。此时，证明我们已经把所有的数组元素都扫描了一遍，那么接下来，我们把哨兵元素的值（ 3）复制到 i 和 j 所指向的元素中，细心的小伙伴可能会发现这个哨兵元素就是我们排序开始时选择的数组最左边的元素（元素 3），\n复制完成之后数组元素变成了：2 1 3 4 5 。\n\n我们发现在元素 3 左边的元素都不大于 3 ，在元素 3 右边的元素都不小于 3 。即我们将数组分隔成了两个部分。\n\n那么接下来就是执行递归的过程了，即分别对数组的左半部分元素（2 1）和数组的右半部分元素（4 5）再进行一次快速排序... 完成之后，整个数组元素就是从小到大已经排好序的了。\n\n\n关于快速排序的实现，请参考\"动画\" 和 \"代码\" 部分。\n\t",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 0
  },
  {
    "basicData": {
      "animation_name": "排序:快速排序",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 4
  },
  {
    "basicData": {
      "code": "\n\n/**\n* C语言实现快速排序\n* Author：指点 \n*/\n#include <stdio.h>\n#define N 5 // 数组元素个数 \n\nvoid quickSort(int left, int right, int a[]) {\n// 这里是递归函数的出口，即如果当前序列只有一个元素，那么无需进行快速排序 \nif (left >= right) {\n\treturn ;\n}\nint i = left;\nint j = right;\nint t = a[left]; // 初始化 i 、j 和哨兵值 \n// 开始扫描数组元素 \nwhile (i < j) {\n\t// 从右向左扫描 \n\twhile (j > i && a[j] >= t) {\n\t\tj--;\n\t}\n\ta[i] = a[j]; // 将数组右边大于哨兵的元素复制到左边 \n\t// 从左向右扫描 \n\twhile (i < j && a[i] <= t) {\n\t\ti++;\n\t}\n\ta[j] = a[i];\n}\n/* 扫描完成后 i 和 j 的值相等，将哨兵值复制到 i 和 j 所指向的元素中 ,\n此时数组的左半部分元素都不大于哨兵元素值，数组右半部分元素都小于哨兵元素值 */\na[i] = t;\n// 递归分别对数组的左半部分元素和右半部分元素进行快速排序 \nquickSort(left, i-1, a);\nquickSort(i+1, right, a); \n}\n\nint main() {\nint a[N] = {3, 5, 4, 1, 2};\nint i = 0;\n\nprintf(\"排序前的数组元素：\");\nfor (; i < N; i++) {\n\tprintf(\"%d \", a[i]);\n}\n\nquickSort(0, N-1, a);\n\nprintf(\"\\n排序后的数组元素：\"); \nfor (i = 0; i < N; i++) {\n\tprintf(\"%d \", a[i]);\n}\n\nreturn 0;\n} \n\t",
      "code_language": -1,
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 2
  },
  {
    "basicData": {
      "text": "\n代码注释写的很详细了，理解了思想，我想写出代码应该是不难的，下面来看一下程序结果：\n\t",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 0
  },
  {
    "basicData": {
      "image_url": "快速排序_1.png",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 1
  }
]