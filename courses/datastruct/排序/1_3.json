[
  {
    "basicData": {
      "text": "\n冒泡排序可谓是我们最常用的排序算法了，不过如果不对它进行优化，它的时间复杂度是 O(n*n)，\n相对于一些高效的排序算法来说还是比较高的，但是其容易实现，这也是为什么这个算法仍是常用的排序算法之一。\n\n冒泡排序的思想是每趟排序中扫描数组中还未排好序的数字，扫描过程中不断比较两个相邻元素的大小，如果不符合指定的排序规则（从大到小或者是从小到大），那么交换两个相邻元素的值。\n\n关于扫描的方向（从左到右或者是从右到左）冒泡排序没有明确的规定，你可以每次从左到右扫描，也可以从右到左扫描，选择不同的扫描方向，在比较两个相邻元素大小的时候注意对应不同的处理就好了。\n\n\n假设这里定义冒泡排序的排序规则为从小到大排序，扫描方向为从左到右扫描。\n\n那么第一趟扫描的目标为将数组中最大的的元素置于数组最后一个位置（扫描的过程中不断比较两个相邻的数字，并且将较大的数字放在靠右边的数组元素中）。\n\n那么第一趟扫描的目标为将数组中第二大的的元素置于数组倒数第二个位置（最大的元素在第一次扫描的过程已经放在了数组的最右边位置） ... 持续这个步骤，直到所有元素都排好序。\n\n\n假设现在我们要用冒泡排序来对数组 3 1 2 4 5 从小到大排序。\n\n一、从左向右扫，把数组元素中最大的元素移动到下标为 4（数组最右边元素） 的位置：\n\n首先，比较第一个元素和第二个元素，此时，3 大于 1，\n左边的数组元素大于右边的数组元素，不符合排序规则，需要交换两个元素的位置。交换完成后数组元素为：1 3 2 4 5 。\n\n接下来继续向右边扫描：3 大于 2 ，同样不符合排序规则，交换两个数组元素，交换完成后的数组元素为：1 2 3 4 5 。\n\n同样，继续向右扫描：3 小于 4，符合排序规则，无需交换元素位置，继续向右扫描：4 小于 5，也无需交换元素位置。至此，第一次扫描结束，数组中最大的元素（5）已经在数组的最右边位置。数组元素为：1 2 3 4 5 。\n\n二、开始第二次从左向右扫描，同样的先是 1 和 2 比较，无需交换，继续向右扫描... \n\n当完成这一趟扫描之后，我们会发现没有任何数组元素进行位置交换，因为第二次扫描时一开始数组元素就已经是从小到大排好序的了。\n\n每一轮扫描过程如果没有任何元素进行交换，那么证明数组已经有序，所以我们可以直接退出排序过程。\n\n\n关于冒泡排序的实现，请参考\"动画\" 和 \"代码\"部分。\n\t",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 0
  },
  {
    "basicData": {
      "animation_name": "排序:冒泡排序",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 4
  },
  {
    "basicData": {
      "code": "\n\n/**\n* C语言实现冒泡排序\n* Author：指点 \n*/ \n#include <stdio.h>\n#define N 1100\n\nint a[N];\n\n// 使用冒泡排序对含有 n 个元素的数组 a 进行从小到大排序 \nvoid bubbleSort(int a[], int n) {\n// flag 用于标志每一轮是否有元素交换了，如果没有，那么证明数组已经有序 \nint i, j, t, flag;\nfor(i = 0; i < n; i++) {\n\tflag = 0;\n\t// 从后面开始往前面扫 \n\tfor(j = n-1; j > i; j--) {\n\t\t// 如果不符合从小到大的顺序，那么交换两个相邻的元素并且将交换标志置为 1  \n\t\tif(a[j] < a[j-1]) {\n\t\t\tflag = 1;\n\t\t\tt = a[j];\n\t\t\ta[j] = a[j-1];\n\t\t\ta[j-1] = t;\n\t\t}\n\t}\n\t// 如果一轮过去之后交换标志还是 0 ，那么证明数组元素已经有序，退出循环 \n\tif(flag == 0) {\n\t\tbreak;\n\t}\n}\n}\n\n// 输出含有 n 个元素的数组 \nvoid print(int a[], int n) {\nint i;\nfor(i = 0; i < n; i++) {\n\tprintf(\"%d \", a[i]);\n}\nprintf(\"\\n\");\n} \n\nint main() {\nint n, i;\nprintf(\"输入元素个数：(1~1100)：\");\nscanf(\"%d\", &n);\n// 对输入的范围进行判断 \nif(n <= 0 || n > 1100) {\n\treturn 0;\n}\nprintf(\"输入%d个整数：\\n\", n);\nfor(i = 0; i < n; i++) {\n\tscanf(\"%d\", a+i);\n}\n\nbubbleSort(a, n);\nprintf(\"排序后的数组：\\n\");\nprint(a, n); \n\nreturn 0;\n} \n\t",
      "code_language": -1,
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 2
  },
  {
    "basicData": {
      "text": "\n看看程序的运行结果：\n\t",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 0
  },
  {
    "basicData": {
      "image_url": "冒泡排序_1.png",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 1
  },
  {
    "basicData": {
      "text": "\n样例通过，这里的代码的平均时间复杂度为 O(n^n)，速度相比快速排序等时间复杂度为 O(n*logn) 的排序还是慢了点，但是其对于一些特殊的数组比如很多元素已经是有序的状态的数组有较好的效果，\n并且如果在中途某趟扫描完成后将数组排好序，那么可以直接结束排序，在某种程度上减小了程序的时间复杂度。\n\t",
      "parent_dir_path": "datastruct/排序"
    },
    "contentType": 0
  }
]