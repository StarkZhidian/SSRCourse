<?xml version="1.0" encoding="UTF-8"?>
<contents>
	<text>
在数据结构中，堆是一种完全二叉树，那么完全二叉树是什么呢？"换行"
设二叉树的深度为h，除第 h 层外，其它各层 (1~h-1) 的结点数都达到最大个数，
第 h 层所有的结点都连续集中在最左边，那么这棵树就是完全二叉树。"换行"
其实就是除了最后一层可以允许节点不排满以外，其余层(1~h-1)的节点都应该排满(2^(n-1) 个, 1&gt;=n&lt;=h-1)，
最后一层的节点一定要从左开始逐渐向右连续排布。"换行"下面是完全二叉树和非完全二叉树的结构图：
	</text>
	<img>
shu_8.png
	</img>
	<text>
上图中完全二叉树和非完全二叉树的区别在于 5 号节点的位置，第二幅图中 2 号节点还没有右子树，
根据定义，5 号节点应该作为 2 号节点的右子树排布(第一幅图)。"换行"
对于完全二叉树来说，如果采用数组来储存二叉树节点，以上图为例，假设根节点(1 号节点)所在数组元素下标为 1，
那么按从上到下、从左到右的顺序，2 号节点所在的数组下标为 2，3 号节点所在的数组下标为 3..."换行"
我们会发现对于一个完全二叉树来说，如果其根节点存在左子树，那么左子树根节点的编号为它的编号的 2 倍，
如果其根节点存在右子树，那么右子树根节点的编号为它的编号的 2 倍加 1。"换行"
基于这个，我们在储存完全二叉树的时候可以采用数组的形式，因为编号相连(节点所在数组下标相连)，
这样就不存在浪费数组空间的现象，因此对于堆的储存我们可以有两种方式：数组形式和链式形式。"换行"
此外，对于堆来说，有"最小堆"和"最大堆"之分。"换行"
最小堆：堆顶元素小于堆的任何一个直接子节点(左右子树的根节点)。"换行" 
最大堆：堆顶元素大于堆的任何一个直接子节点(左右子树的根节点)。"换行" 
请注意：堆的子树亦是堆。"换行"
下面是最小堆和最大堆的结构图：
	</text>
	<img>
shu_9.png
	</img>
	<text>
请注意，图中的数字并不是代表树节点的编号，而是代表树节点储存的数值的值。"换行"
关于堆的基本操作，请参考"动画"和"代码"部分。"换行"
	</text>
	<link>
参考博客：http://blog.csdn.net/hacker_zhidian/article/details/60801415
	</link>
	<animation html_path=""></animation>
	<code>

/**
* 实现最大堆的基本操作： 创建堆、取堆顶元素、删除堆顶元素、向堆中插入元素 
* 使用数组来保存堆元素，这里堆元素储存的类型是一个结构体
* 结构体中保存的数据类型为 int 类型，使用了 typedef 关键字，如有需要请自行更改 
*/
#include &lt;stdio.h&gt;
// 堆的最大储存元素个数
#define  MAX_SIZE 1000
// 堆中已经储存的元素个数 
int nodeSum; 

// 以 int 类型为堆节点储存的数据类型
typedef int dataType;

// 表示堆节点储存的数据类型的结构体 
typedef struct Element {
dataType data;
}Element;

// 创建储存堆节点的数组 
Element heap[MAX_SIZE];

// 调整以编号为 n 的节点作为根节点的堆，使其成为一个最大堆 
void maxHeap(int n) {
// 编号为 n 的堆节点的左右孩子的节点所在数组下标 
int l = 2*n;
int r = l+1;
// 储存最大值的堆节点所在数组下标 
int large = n; 
// 用于进行交换的中间变量 
dataType t; 

// 如果存在左孩子，那么比较左孩子和当前节点的值的大小并找出最大值所在下标 
if(l &lt;= nodeSum &amp;&amp; heap[large].data &lt; heap[l].data) {
	large = l;
}
// 如果存在左孩子，那么比较右孩子和当前节点的值的大小并找出最大值所在下标
if(r &lt;= nodeSum &amp;&amp; heap[large].data &lt; heap[r].data) {
	large = r;
}
/*
 * 如果最大值所在下标不是当前节点所在下标，那么交换两者的值
 * 交换之后，编号为 n 的节点符合最大堆的性质，
 * 但是交换之后的编号为 large 的节点不一定符合，
 * 所以需要通过递归来对编号为 large 的节点进行调整 
 */
if(large != n) {
	t = heap[large].data;
	heap[large].data = heap[n].data;
	heap[n].data = t;
	// 递归对编号为 large 的节点进行调整 
	maxHeap(large); 
}
}

// 删除堆顶元素，并且调整整个堆，使其仍然为一个最大堆 
void eraseTop() {
// 将最后一个堆元素提至堆顶并且将堆节点个数减 1  
heap[1] = heap[nodeSum--]; 
// 重新调整整个堆，使其仍然为一个最大堆
maxHeap(1); 
}

// 获取堆顶元素 
dataType getTop() {
return heap[1].data; 
} 

// 向堆中插入元素 
void insert(Element e) {
int i;
// 检测堆中的元素是否已满 
if(nodeSum &gt;= MAX_SIZE-1) {
	printf("堆已满，插入元素失败！");
	return ; 
}
// 堆节点总数加 1 ，并且把新元素插入堆的末尾 
heap[++nodeSum] = e;
// 从下至上调整整个堆，使其仍为一个最大堆 
for(i = nodeSum/2; i &gt;= 1; i--) {
	maxHeap(i);
} 
} 

int main() {
int i;
Element ele;
ele.data = 12; 

printf("输入堆元素个数：");
scanf("%d", &amp;nodeSum);
printf("输入 %d 个堆元素：\n", nodeSum);
for(i = 1; i &lt;= nodeSum; i++) {
	scanf("%d", &amp;heap[i].data);
}

// 向堆中插入一个元素 
insert(ele);

// 从堆的第一个非叶子节点开始向上调整，使整个堆成为一个最大堆 
for(i = nodeSum/2; i &gt;= 1; i--) {
	maxHeap(i); 
} 

/**
 * 输出当前堆中的所有元素值，每次将堆顶元素输出，
 * 并将输出了的堆顶元素删除，重新调整堆，即为从小到大输出堆元素 
 */ 
while(nodeSum &gt; 0) {
	printf("当前堆顶元素为 %d\n", getTop());
	eraseTop();
}

return 0;
}

	</code>
	<text>
堆的相关操作的关键在于对堆的调整，在插入、删除堆顶元素的时候调整堆，使其仍然为一个最大(最小)堆。"换行"
堆可以用来对元素进行排序，即"堆排序"，上面的代码已经有一个"堆排序"的雏形了。"换行"
堆的一个重要应用是取出 n 个数组元素中的前 k(k &lt;= n) 大的数：维护一个能储存 k 个元素的最小堆，
每次将数组元素和堆顶比较，如果堆顶元素较大，则不管，否则用这个元素代替堆顶元素，并重新调整堆..."换行"
总的时间复杂度为O(n*log(k))，对于取出数组元素中的前 k 小的数也是同理。"换行"
另外，C++ STL 模板中的优先队列(priority_queue)就是用的堆来实现的。"换行"
最后是程序的运行结果：
	</text>
	<img>
shu_10.png
	</img>
</contents>