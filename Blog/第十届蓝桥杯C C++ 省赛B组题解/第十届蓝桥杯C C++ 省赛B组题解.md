@[TOC]

## 前言

又是一年一度的蓝桥杯，这次也应该是我大学最后一次学科竞赛了，今年的省赛题型和往届有些不同，代码填空没有了，只有结果填空和编程大题，不过坑还是一样的多，稍不注意就出错了。这里记录一下自己的做题思路，因为没有现场判题，所以我也不能确定我的答案一定是对的，小伙伴们看看一些题目的思路就好了。话不多说，看题。

[题目下载链接](https://download.csdn.net/download/hacker_zhidian/11057008)



## 试题 A: 组队

本题总分：5 分

作为篮球队教练，你需要从以下名单中选出 1 号位至 5 号位各一名球员，
组成球队的首发阵容。
每位球员担任 1 号位至 5 号位时的评分如下表所示。请你计算首发阵容 1
号位至 5 号位的评分之和最大可能是多少？
![在这里插入图片描述](https://img-blog.csdnimg.cn/20190325015615726.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0hhY2tlcl9aaGlEaWFu,size_16,color_FFFFFF,t_70)
这个就是取某个位置中分数最高的队员，当然要注意一个队员只能在一个位置，不能同时占多个位置。

答案：**490**


## 试题 B: 年号字串

本题总分：5 分

小明用字母 A 对应数字 1，B 对应 2，以此类推，用 Z 对应 26。对于 27
以上的数字，小明用两位或更长位的字符串来对应，例如 AA 对应 27，AB 对
应 28，AZ 对应 52，LQ 对应 329。
请问 2019 对应的字符串是什么？
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个大写英文字符串，在提交答案时只填写这个字符串，注意全部大写，填写多
余的内容将无法得分。

这题就是用 A~Z 来表示 1 ~ 26 这几个数，然后要将 2019 用 A~Z 这 26 个字母表示出来，其实就类似于进制转换，代码：

```c

#include <iostream>
using namespace std;

void solve(int n) {
	if (!n) {
		return ;
	}
	solve(n / 26);
	cout << (char)(n % 26 + 64);
}

int main() {
	solve(2019);
	return 0;
} 
```

答案：**BYQ**


## 试题 C: 数列求值

本题总分：10 分

给定数列 1, 1, 1, 3, 5, 9, 17, …，从第 4 项开始，每项都是前 3 项的和。求
第 20190324 项的最后 4 位数字。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个 4 位整数（提示：答案的千位不为 0） ，在提交答案时只填写这个整数，填写
多余的内容将无法得分。

类似于斐波那契数列的第 n 项，只不过递推式变了，不能用递归，否则爆栈，还有一个问题是直接算到第 20190324 项肯定是会溢出的，在计算过程中要进行取余操作。代码：

```c

#include <iostream>
using namespace std;

int solve(int n) {
	if (n <= 3) {
		return 1;
	}
	int a = 1, b = 1, c = 1, res;
	for (int i = 4; i <= n; i++) {
         // 这里要记得取余
		res = (a + b + c) % 10000;
		a = b;
		b = c;
		c = res;
	}
	return res;
}

int main() {
	cout << solve(20190324) << endl;
	return 0;
}
```

答案：**4659**



## 试题 D: 数的分解
本题总分：10 分

【问题描述】
把 2019 分解成 3 个各不相同的正整数之和，并且要求每个正整数都不包
含数字 2 和 4，一共有多少种不同的分解方法？
注意交换 3 个整数的顺序被视为同一种方法，例如 1000+1001+18 和
1001+1000+18 被视为同一种。
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个整数，在提交答案时只填写这个整数，填写多余的内容将无法得分。

暴力题，但是需要注意的是去重，题目说了不同顺序而数字相同的情况只能算一种，比赛的时候真的把这道题想简单了，以为只用一个标记数组就可以去重，不知道的是还有可能有这种情况：假设 a + b + c == 2019，然后再假设 d + e + f == 2019，如果这个时候 a + d + f == 2019，这其实可以算是一种新的情况，但是如果只采用一个标记数组的话会认为 a, d, f 这三个数字都出现过，即漏了这种情况。在这里我将 a b c 通过 10 进制运算的形式组成一个新的数字，然后放在 mark 标记数组里面，如果下一次有数字符合 a + b + c ==2019 ，则将他们也组成一个新的数字，然后在已有的 mark 数组里面找，如果找到了，则证明重合，否则就是新情况，放入 mark 数组中记录。

上面是之前的想法，把问题想复杂了，感谢评论区小伙伴的指正，我们可以让 3 个变量（假设为 a, b, c）从 1 开始枚举，即暴力，这样的出来的结果肯定会有重复，重复原因就是 a 可能和 b、c 重合，同样，b 也可能和 a、c 出现重合，c 也可能和 a、b 重合。即需要把结果除以 6 。

另一种更简单的想法则是在循环时就控制 a, b 和 c 的起始值，即 a 从 1 开始， b 从 a + 1 开始，c 从 b + 1 开始。这样 a, b 和 c 就不会相等，同时也不会出现重复，因为每一次循环得到的 a, b 和 c 和之前出现过的 a, b 和 c 中必定至少有一个数不同，这样得到的结果就是最终结果。从时间复杂度上将，第二种思路是比第一种思路快的。代码：

```c

#include <iostream>
#include <cmath>
#include <algorithm>
using namespace std;

// 判断某个数字位中是否包含 2 和 4 
bool judge(int n) {
	int t;
	while (n) {
		if (((t = n % 10) == 2) || t == 4) {
			return true;
		}
		n /= 10;
	}
	return false;
}

bool check(int a, int b, int c) {
	// 有数字出现 2 和 4，或者出现重复数字，返回 0 
	if (judge(a) || judge(b) || judge(c) || 
		a == b || a == c || b == c) {
		return false;
	}
	return true;
}

/**
 * 第一种思路：直接枚举后将结果 / 6
 */
int main() {
	int res = 0;
	for (int i = 1; i < 2018; i++) {
		for (int j = 1; j < 2018; j++) {
			for (int k = 1; k < 2018; k++) {
				if (i + j + k == 2019) {
					res += check(i, j, k);
				}
			}
		}
	}
	cout << (res / 6) << endl;
	return 0;
} 

/**
 * 第二种思路：循环的时候控制变量的起始值：
 */
int main() {
	int res = 0;
	for (int i = 1; i < 2018; i++) {
		for (int j = i + 1; j < 2018; j++) {
			for (int k = j + 1; k < 2018; k++) {
				if (i + j + k == 2019) {
					res += check(i, j, k);
				}
			}
		}
	}
	cout << res << endl;
	return 0;
} 
```

答案：**40785**



## 试题 E: 迷宫
本题总分：15 分
【问题描述】
下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可
以通行的地方。
010000
000100
001001
110000
迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这
个它的上、下、左、右四个方向之一。
对于上面的迷宫，从入口开始，可以按DRRURRDDDR 的顺序通过迷宫，
一共 10 步。其中 D、U、L、R 分别表示向下、向上、向左、向右走。
对于下面这个更复杂的迷宫（30 行 50 列） ，请找出一种通过迷宫的方式，
其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。
请注意在字典序中D<L<R<U。（如果你把以下文字复制到文本文件中，请务
必检查复制的内容是否与文档中的一致。在试题目录下有一个文件 maze.txt，
内容与下面的文本相同）
01010101001011001001010110010110100100001000101010
00001000100000101010010000100000001001100110100101
01111011010010001000001101001011100011000000010000
01000000001010100011010000101000001010101011001011
00011111000000101000010010100010100000101100000000
11001000110101000010101100011010011010101011110111
00011011010101001001001010000001000101001110000000
10100000101000100110101010111110011000010000111010
00111000001010100001100010000001000101001100001001
11000110100001110010001001010101010101010001101000
00010000100100000101001010101110100010101010000101
11100100101001001000010000010101010100100100010100
00000010000000101011001111010001100000101010100011
10101010011100001000011000010110011110110100001000
10101010100001101010100101000010100000111011101001
10000000101100010000101100101101001011100000000100
10101001000000010100100001000100000100011110101001
00101001010101101001010100011010101101110000110101
11001010000100001100000010100101000001000111000010
00001000110000110101101000000100101001001000011101
10100101000101000000001110110010110101101010100001
00101000010000110101010000100010001001000100010101
10100001000110010001000010101001010101011111010010
00000100101000000110010100101001000001000000000010
11010000001001110111001001000011101001011011101000
00000110100010001000100000001000011101000000110011
10101000101000100010001111100010101001010000001000
10000010100101001010110000000100101010001011101000
00111100001000010000000110111000000001000000001011
10000001100111010111010001000110111010101101111000
【答案提交】
这是一道结果填空的题，你只需要算出结果后提交即可。本题的结果为一
个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填
写多余的内容将无法得分。



如何把地图数据放入代码中是一个问题，一般用文本替换。就是一道经典的寻路问题，比赛的时候用的 DFS，程序运行了近 1 小时都没得出答案。。。最后还爆栈了，这么大的数据量早该想到的，换用 BFS，因为 BFS 得到的解总是最优解，即步数最少的解，那么我们在遍历的时候按照字典序从小到大的顺序进行四个方向遍历进行了：

```c

#include <iostream>
#include <cstdio>  
using namespace std;

int map[][50] = {
	0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 
    0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 
    0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 
    0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 
    0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 
    1, 1, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 1, 1, 
    0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 
    1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 
    0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 0, 1, 
    1, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 
    0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 
    1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 
    0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 
    1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 
    1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 
    1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 
    1, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 0, 1, 
    0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 
    1, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 0, 
    0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 
    1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 
    0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 
    1, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 
    0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 
    1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 
    0, 0, 0, 0, 0, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 
    1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 
    1, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 
    0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 
    1, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 0, 0, 0
};
const int n = 30, m = 50;
int res = 0x7fffffff;
int book[n][m];

struct node {
	int x;
	int y;
	int s; // 路程 
	int f; // 上一个位置下标 
	char ch; // 上一个走向 
};
node que[n*m];
int head, tail;
// 按字典序从小到大顺序排列
int next_[4][2] = {
    {1, 0}, //下
    {0, -1}, // 左
    {0, 1}, // 右
    {-1, 0} // 上
};

void print(int index) {
	if (index == 0) {
		return ;
	}
	print(que[index].f);
	cout << que[index].ch;
}

void bfs() {
	que[tail].x = 0;
	que[tail].y = 0;
	que[tail].s = 0;
	que[tail].f = -1;
	que[tail++].ch = 0;
	book[0][0] = 1;
	int flag = 0;
	
	while(head < tail) {
		int nX, nY;
		for(int i = 0; i < 4; i++) {
			nX = next_[i][0] + que[head].x;
			nY = next_[i][1] + que[head].y;
			if (nX < 0 || nX >= n || nY < 0 || nY >= m) {
				continue;
			}
			if (map[nX][nY] == 0 && book[nX][nY] == 0) {
				book[nX][nY] = 1;
				que[tail].x = nX;
				que[tail].y = nY;
				que[tail].s = que[head].s + 1;
				que[tail].f = head;
				if (next_[i][0]) {
					que[tail].ch = (next_[i][0] == 1 ? 'D' : 'U');
				} else if (next_[i][1]) {
					que[tail].ch = (next_[i][1] == 1 ? 'R' : 'L');
				}
				tail++;
				// 找到出口 
				if(nX == n - 1 && nY == m - 1) {
					flag = 1;
					break;
				}
			}
		}
		if (flag == 1) {
			break;
		}
		head++;
	}
	print(tail - 1); 
}

int main() {
	bfs();
	
	return 0;
}
```

答案：**DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR**



## 试题 F: 特别数的和
时间限制: 1.0s 内存限制: 256.0MB 本题总分：15 分
【问题描述】
小明对数位中含有 2、0、1、9 的数字很感兴趣（不包括前导 0） ，在 1 到
40 中这样的数包括 1、2、9、10 至 32、39 和 40，共 28 个，他们的和是 574。
请问，在 1 到 n 中，所有这样的数的和是多少？
【输入格式】
输入一行包含两个整数 n。
【输出格式】
输出一行，包含一个整数，表示满足条件的数的和。
【样例输入】
40
【样例输出】
574
【评测用例规模与约定】
对于 20% 的评测用例，1 ≤ n ≤ 10。
对于 50% 的评测用例，1 ≤ n ≤ 100。
对于 80% 的评测用例，1 ≤ n ≤ 1000。
对于所有评测用例，1 ≤ n ≤ 10000。



这题主要是找出在一定范围内数位中出现 2、0、1、9 这四个数字之一的所有数字，感觉这个有规律，懒得找了，直接暴力，最大范围为 10000， O(n) 复杂度应该能过，代码：

```c

#include <iostream>
using namespace std;

// 判断某个数字位中是否包含 2, 0, 1, 9 这四个数字 
bool judge(int n) {
	int t;
	while (n) {
		if (((t = n % 10) == 2) || t == 0 || t == 1 || t == 9) {
			return true;
		}
		n /= 10;
	}
	return false;
}

int main() {
	int n, res = 0;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		if (judge(i)) {
			res += i;
		}
	}
	cout << res << endl;
	
	return 0;
}
```



## 试题 G: 完全二叉树的权值
时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分
【问题描述】
给定一棵包含 N 个节点的完全二叉树，树上每个节点都有一个权值，按从
上到下、从左到右的顺序依次是 A 1 , A 2 , ··· A N ，如下图所示：
现在小明要把相同深度的节点的权值加在一起，他想知道哪个深度的节点
权值之和最大？如果有多个深度的权值和同为最大，请你输出其中最小的深度。
注：根的深度是 1。
【输入格式】
第一行包含一个整数 N。
第二行包含 N 个整数 A 1 , A 2 , ··· A N 。
【输出格式】
输出一个整数代表答案。
【样例输入】
7
1 6 5 4 3 2 1
试题G: 完全二叉树的权值 10
第十届蓝桥杯大赛软件类省赛 C/C++ 大学 B 组
【样例输出】
2
【评测用例规模与约定】
对于所有评测用例，1 ≤ N ≤ 100000，−100000 ≤ A i ≤ 100000。



这题如果了解完全二叉树的特性就不难了，完全二叉树的第 i 层的最大节点数为 `2^(i-1)` 个，那么对于某个下标的元素，我们只需要知道他属于哪一层就行了，因为给的数据范围为 100000 个节点以内，这么多节点组成的完全二叉树有多少层呢？我们知道完全二叉树的节点总数和深度的关系为深度为 n 的完全二叉树最多拥有 `2^n - 1` 个节点，也就是当完全二叉树为满二叉树的时候节点数最多。而一颗层数为 17 层的完全二叉树最大节点数为 `2^17 - 1 = 131071`，已经大于给定的 n 的范围，那么我们计算出每一个节点所属的深度层，再统计就很简单了，因为题目中给的根的深度为 1, 那么我们计算的深度需要往后移一位，即最大深度为 18，下面是代码：

```c

#include <iostream>
#include <cstdio>
using namespace std; 
const int MAX_DEEP = 18;
long long temp[MAX_DEEP + 1];

// 获取下标为 n 的节点的深度 
int getDeep(int n) {
	int res = 0;
	while (n > 0) {
		n /= 2;
		res++;
	} 
	return res;
}

int main() {
	int n, t;
	cin >> n;
	for (int i = 1; i <= n; i++) {
		scanf("%d", &t);
		// 求出当前节点所属的深度层并加入当前深度层节点的权值和中 
		temp[getDeep(i)] += t;
	} 
	int res = 0x80000000, resDeep;
	// 节点权值和最大的深度层 
	for (int i = 1; i <= MAX_DEEP; i++) {
		if (temp[i] > res) {
			res = temp[i];
			resDeep = i;
		}
	}
	cout << resDeep << endl;
	return 0;
}
```



## 试题 H: 等差数列
时间限制: 1.0s 内存限制: 256.0MB 本题总分：20 分
【问题描述】
数学老师给小明出了一道等差数列求和的题目。但是粗心的小明忘记了一
部分的数列，只记得其中 N 个整数。
现在给出这 N 个整数，小明想知道包含这 N 个整数的最短的等差数列有
几项？
【输入格式】
输入的第一行包含一个整数 N。
第二行包含 N 个整数 A 1 ,A 2 ,··· ,A N 。(注意 A 1 ∼ A N 并不一定是按等差数
列中的顺序给出)
【输出格式】
输出一个整数表示答案。
【样例输入】
5
2 6 4 10 20
【样例输出】
10
【样例说明】
包含 2、6、4、10、20 的最短的等差数列是 2、4、6、8、10、12、14、16、
18、20。

【评测用例规模与约定】
对于所有评测用例，2 ≤ N ≤ 100000，0 ≤ A i ≤ 10 9 。

这题感觉有点简单，不知道是不是有坑，思路就是求出给出的数字中最小公差，然后用数字中的最大数字 - 最小数字除以 2 再加 1 就行了，注意公差为 0 的时候的处理。

补充：掉进坑里了，感谢评论区小伙伴指出，正确的思路应该是先将给定的数字进行排序，**公差应该是排序之后求出所有相邻数字之间差值的最大公约数。** 同样注意公差为 0 时的处理，再次感谢评论区的小伙伴，更正后代码：

```c

#include <iostream>
#include <algorithm>
#include <cmath>
using namespace std;

int value[100010]; 

int gcd(int a, int b) {
	int t;
	while (a) {
		t = a;
		a = b % a;
		b = t;
	}
	return b;
}

int main() {
	int n, d, t;
	int maxx = 0, minn = 0x7fffffff;
	cin >> n;
	for (int i = 0; i < n; i++) {
		scanf("%d", value + i);
		maxx = max(maxx, value[i]);
		minn = min(minn, value[i]);
	}
	sort(value, value + n);
	// 求出所有相邻数字差值的最大公约数 
	d = value[1] - value[0];
	for (int i = 2; i < n; i++) {
		d = gcd(d, value[i] - value[i-1]);
	}
	// 注意公差为 0 的处理 
	if (d == 0) {
		cout << n << endl;
	} else {
		cout << ((maxx - minn) / d + 1) << endl; 
	}
	
	return 0;
} 
```



## 试题 I: 后缀表达式
时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分
【问题描述】
给定 N 个加号、M 个减号以及 N + M + 1 个整数 A 1 ,A 2 ,··· ,A N+M+1 ，小
明想知道在所有由这 N 个加号、M 个减号以及 N + M +1 个整数凑出的合法的
后缀表达式中，结果最大的是哪一个？
请你输出这个最大的结果。
例如使用1 2 3 + -，则 “2 3 + 1 -” 这个后缀表达式结果是 4，是最大的。
【输入格式】
第一行包含两个整数 N 和 M。
第二行包含 N + M + 1 个整数 A 1 ,A 2 ,··· ,A N+M+1 。
【输出格式】
输出一个整数，代表答案。
【样例输入】
1 1
1 2 3
【样例输出】
4
【评测用例规模与约定】
对于所有评测用例，0 ≤ N, M ≤ 100000，−10 9 ≤ A i ≤ 10 9 。

这题一开始有点懵，还是被后缀表达式这个概念蒙蔽了，从概念上讲，后缀表达式的意义和中缀表达式应该是一样的，想想我们熟悉的中缀表达式，我们可以自由定制数字运算的顺序，那么后缀表达式也应该有这种能力，即能随意组合运算顺序，我们知道这个概念就行。第二点是如果只有 + 、- 运算符，那么所有的数字都可以看成是相加的，-运算符可以看成负号。那么题目就可以看成有 N + M + 1 个数字进行相加，但是必须要有 M 个数字变成其本身的相反数，我们很容易想到可以把负数变成它的相反数，就成了正数，顺序应该是先将绝对值最大的负数变成正数，再是其他的数字。我们还需要讨论负数的个数和 M 的关系：1、给定的数字本身中负数的个数小于 M，这种情况下剩下绝对值最小的几个负数。2、给定的数字本身中负数的个数大于 M， 这种情况和 1 相似。3、给定的数字本身中负数的个数等于 M，这种情况全是正数，皆大欢喜。最后做加法就行了。下面是代码：

```c

#include <iostream>
#include <algorithm>
#include <cmath>
#include <cstdio>
using namespace std;

const int MAXN = 200020;
int nums[MAXN];

// 自定义排序函数：按绝对值从大到小排序 
bool com(int a, int b) {
	return abs(a) > abs(b);
}

int main() {
	int N, M;
	cin >> N >> M;
	int n  = N + M + 1;
	long long res = 0;
	for (int i = 0; i < n; i++) {
		scanf("%d", nums + i);
	}
	sort(nums, nums + n, com);
	// 将负数变成正数 
	for (int i = 0; i < n && M > 0; i++) {
		if (nums[i] < 0) {
			nums[i] = -nums[i];
			M--;
		}
	}
	// 如果还存在负号，则将最后的数字变成负数 
	if (M) {
		for (int i = n - M; i < n; i++) {
			nums[i] = -nums[i];
		} 
	} 
	// 求和 
	for (int i = 0; i < n; i++) {
		res += nums[i];
	}
	cout << res << endl;
	return 0;
} 
```



## 试题 J: 灵能传输
时间限制: 1.0s 内存限制: 256.0MB 本题总分：25 分
【题目背景】
在游戏《星际争霸 II》中，高阶圣堂武士作为星灵的重要 AOE 单位，在
游戏的中后期发挥着重要的作用，其技能”灵能风暴“可以消耗大量的灵能对
一片区域内的敌军造成毁灭性的伤害。经常用于对抗人类的生化部队和虫族的
刺蛇飞龙等低血量单位。
【问题描述】
你控制着 n 名高阶圣堂武士，方便起见标为 1,2,··· ,n。每名高阶圣堂武士
需要一定的灵能来战斗，每个人有一个灵能值 a i 表示其拥有的灵能的多少（a i
非负表示这名高阶圣堂武士比在最佳状态下多余了 a i 点灵能，a i 为负则表示这
名高阶圣堂武士还需要 −a i 点灵能才能到达最佳战斗状态） 。现在系统赋予了
你的高阶圣堂武士一个能力，传递灵能，每次你可以选择一个 i ∈ [2,n − 1]，若
a i ≥ 0 则其两旁的高阶圣堂武士，也就是 i − 1、i + 1 这两名高阶圣堂武士会从
i 这名高阶圣堂武士这里各抽取 a i 点灵能；若 a i < 0 则其两旁的高阶圣堂武士，
也就是 i−1,i+1 这两名高阶圣堂武士会给 i 这名高阶圣堂武士 −a i 点灵能。形
式化来讲就是 a i−1 + = a i ,a i+1 + = a i ,a i − = 2a i 。
灵能是非常高效的作战工具，同时也非常危险且不稳定，一位高阶圣堂
武士拥有的灵能过多或者过少都不好，定义一组高阶圣堂武士的不稳定度为
max n
i=1 |a i |，请你通过不限次数的传递灵能操作使得你控制的这一组高阶圣堂武
士的不稳定度最小。
【输入格式】
本题包含多组询问。输入的第一行包含一个正整数 T 表示询问组数。
接下来依次输入每一组询问。
每组询问的第一行包含一个正整数 n，表示高阶圣堂武士的数量。
接下来一行包含 n 个数 a 1 ,a 2 ,··· ,a n 。
试题 J: 灵能传输 15
第十届蓝桥杯大赛软件类省赛C/C++大学B组
【输出格式】
输出 T 行。每行一个整数依次表示每组询问的答案。
【样例输入】
3
3
5 -2 3
4
0 0 0 0
3
1 2 3
【样例输出】
3
0
3
【样例说明】
对于第一组询问：
对 2 号高阶圣堂武士进行传输操作后 a 1 = 3，a 2 = 2，a 3 = 1。答案为 3。
对于第二组询问：
这一组高阶圣堂武士拥有的灵能都正好可以让他们达到最佳战斗状态。
【样例输入】
3
4
-1 -2 -3 7
4
2 3 4 -8
5
-1 -1 6 -1 -1
【样例输出】
5
7
4
【样例输入】
见文件trans3.in。
【样例输出】
见文件trans3.ans。
【数据规模与约定】
对于所有评测用例，T ≤ 3，3 ≤ n ≤ 300000，|a i | ≤ 10 9 。
评测时将使用 25 个评测用例测试你的程序，每个评测用例的限制如下：
评测用例编号 n |a i | 特殊性质
1 = 3 ≤ 1000 无
2,3 ≤ 5 ≤ 1000 无
4,5,6,7 ≤ 10 ≤ 1000 无
8,9,10 ≤ 20 ≤ 1000 无
11 ≤ 100 ≤ 10 9 所有 a i 非负
12,13,14 ≤ 100 ≤ 10 9 无
15,16 ≤ 500 ≤ 10 9 无
17,18,19 ≤ 5000 ≤ 10 9 无
20 ≤ 5000 ≤ 10 9 所有 a i 非负
21 ≤ 100000 ≤ 10 9 所有 a i 非负
22,23 ≤ 100000 ≤ 10 9 无
24,25 ≤ 300000 ≤ 10 9 无
注意：本题输入量较大请使用快速的读入方式。



这题题量有点大。。。简单来说就是给定一组数，我们的目标是通过两种操作使得其中的绝对值最大的数达到最小，这两种操作是：

1、如果 a[i] > 0 并且 a[i - 1] 或者 a[i+1] 小于 0，我们可以将 a[i] 借给 i-1 元素和 i+1 元素，同时 a[i] 要变成 -a[i]。

2、如果 a[i] < 0 并且 a[i - 1] 或者 a[i+1] 大于 0，我们可以将 a[i-1] 和 a[i+1] 各借 abs(a[i]) 给 i 元素，之后 i 元素的值变成 -a[i] 也就是正数（a[i] 本身是小于 0 的），同时 a[i - 1] 和 a[i + 1] 要减掉 abs(a[i])。

我们考虑几种情况：

1、所有的数字都为正数或者都为负数，即所有的数字都同号。这种情况是没法借的，因为不符合操作要求，因此这种情况求出数组中绝对值最大的数即可。

2、对于 a[i]，如果 a[i] 是正数，并且 a[i - 1] 和 a[i + 1] 至少有一个负数，那么我们的目标就是把那个绝对值最大的负数的绝对值缩小，这个时候如果另一边是正数，则需要考虑操作之后是否会产生新的绝对值更大的正数，比如现在有三个数：5 5 -6，如果我们把中间那个 5 按上面的操作 1 变换之后：10 -5 -1，绝对值最大数变成了 10，而之前是 6，显然不行。如果这三个数是这样的：1 5 -7，那么我们就可以按操作 1 变换：6 -5 -2，最大绝对值从 7 减小到了 6，是可行的。那么变换条件是什么呢？这里假设 a[i - 1] 是正数，a[i + 1] 是负数，那么条件可以写成：a[i - 1] + a[i] < abs(a[i + 1])。而如果 a[i - 1] 和 a[i + 1] 都是负数的时候，当两边的绝对值有一个大于 a[i] 时，就可以进行操作 1 变换。

3、对于 a[i] 是负数的时候，如果 a[i - 1] 是负数， a[i+1] 是正数，那么确保 a[i + 1] > abs(a[i] + a[i-1])，就可以进行操作 2 变换，如果两边都是正数则只要有一边的值大于 abs(a[i]) 时就可以进行操作 2 变换。最后给出代码：

```c

#include <cstdio>
#include <cmath>
#include <iostream>
using namespace std;

const int MAXN = 300010;
int nums[MAXN]; 

// 判断 a 和 b 是否异号 
bool judgeYi(int a, int b) {
	return a > 0 && b < 0 || a < 0 && b > 0;
} 

int main() {
	int T, n;
	cin >> T;
	while (T--) {
		cin >> n;
		// 标志负数和正数是否出现 
		bool hasNe = false, hasPo = false;
		int res = 0;
		for (int i = 0; i < n; i++) {
			scanf("%d", &nums[i]);
			if (nums[i] < 0) {
				hasNe = true;
			} else if (nums[i] > 0) {
				hasPo = true;
			}
		}
		// 如果数组中同时存在正负数，则判断能否进行操作 1 和 操作 2 
		if (hasNe && hasPo) {
			bool canNext;
			do {
				canNext = false;
				for (int i = 1; i < n - 1; i++) {
					// nums[i] 和 nums[i-1] 或 nums[i+1] 异号 
					if (judgeYi(nums[i], nums[i-1]) || judgeYi(nums[i], nums[i+1])) {
						if (nums[i] > 0) {
							// nums[i-1] 和 nums[i+1] 异号，
							// 这里的 if 和 else 可以合并，为了逻辑清晰，这里分开写 
							if (judgeYi(nums[i-1], nums[i+1])) {
								if ((nums[i-1] > 0 && abs(nums[i+1]) > nums[i-1] + nums[i]) || 
									(nums[i+1] > 0 && abs(nums[i-1]) > nums[i+1] + nums[i])) {
									nums[i+1] += nums[i];
									nums[i-1] += nums[i];
									nums[i] = -nums[i];
									canNext = true;
								}
							} else { // nums[i-1] 和 nums[i+1] 同号，都 < 0 
								if (abs(nums[i-1]) > nums[i] || abs(nums[i+1]) > nums[i]) {
									nums[i+1] += nums[i];
									nums[i-1] += nums[i];
									nums[i] = -nums[i];
									canNext = true;
								} 
							} 
						} else if (nums[i] < 0) {
							// nums[i-1] 和 nums[i+1] 异号 
							if (judgeYi(nums[i-1], nums[i+1])) {
								if ((nums[i-1] > 0 && nums[i-1] > abs(nums[i+1] + nums[i])) || 
									(nums[i+1] > 0 && nums[i+1] > abs(nums[i-1] + nums[i]))) {
									nums[i+1] += nums[i];
									nums[i-1] += nums[i];
									nums[i] = -nums[i];
									canNext = true;
								}
							} else { // nums[i-1] 和 nums[i+1] 同号，都 > 0 
								if (nums[i-1] > abs(nums[i]) || nums[i+1] > abs(nums[i])) {
									nums[i+1] += nums[i];
									nums[i-1] += nums[i];
									nums[i] = -nums[i];
									canNext = true;
								} 
							} 
						}
					} 
				}
			} while (canNext);
		}
		int t;
		// 求绝对值最大的值 
		for (int i = 0; i < n; i++) {
			res = max(res, abs(nums[i]));
		}
		cout << res << endl;
	}
	
	return 0;
}
```

好了，暂时就写到这里了，总的来说，难度还是有的，尤其是在考场环境下，除非真的是身经百战，不然多少还是会有点紧张的，而有些题目坑又特别多，所以要真正做到高分除了实力过硬之外还得有良好的心理素质。

以上题解只是个人思路，不保证正确性，如果对您有帮助，不妨给个赞支持一下，如果博客中有什么不正确的地方，请多多指点。

谢谢观看。。。